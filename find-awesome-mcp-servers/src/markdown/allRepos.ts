import { readFileSync } from "fs";
import { EnrichedRepo } from "../schema/github.js";
import { repoLink, sanitizeDescription } from "../utils/format.js";
import { licenseBadge } from "./badges.js";
import {
  centeredHeader,
  dashboardGrid,
  githubAlert,
  licenseDistribution,
  mermaidPieChart,
} from "./components.js";
import { navigationBar, pageFooter } from "./navigation.js";
import { BADGE_STYLE, COLORS, LEADERBOARD_COPY } from "./theme.js";

const TABLE_HEADER = [
  "| Repository | Stars | Forks | License | Created | Updated | Description |",
  "| ---------- | ----: | ----: | ------- | ------- | ------- | ----------- |",
];

function allReposRow(repo: EnrichedRepo): string {
  const link = repoLink(repo);
  const stars = repo.stargazers_count.toLocaleString();
  const forks = repo.forks_count.toLocaleString();
  const license = licenseBadge(repo.license);
  const created = repo.created_at.split("T")[0];
  const updated = repo.pushed_at.split("T")[0];
  const description = sanitizeDescription(repo.description);

  return `| ${link} | ${stars} | ${forks} | ${license} | ${created} | ${updated} | ${description} |`;
}

function getFullName(repo: EnrichedRepo): string {
  return `${repo.owner.login}/${repo.name}`;
}

function sortReposAlphabetically(repos: EnrichedRepo[]): EnrichedRepo[] {
  return [...repos].sort((a, b) =>
    getFullName(a).toLowerCase().localeCompare(getFullName(b).toLowerCase()),
  );
}

export function generateAllReposPage(repos: EnrichedRepo[]): string {
  const copy = LEADERBOARD_COPY.allRepos;
  const generatedDate = new Date().toISOString().split("T")[0];
  const sortedRepos = sortReposAlphabetically(repos);

  const sections = [
    navigationBar("allRepos"),
    centeredHeader(copy, generatedDate),
    dashboardGrid([
      {
        label: "Total Repositories",
        value: repos.length,
        color: COLORS.totalRepos,
      },
      {
        label: "Combined Stars",
        value: `${Math.round(repos.reduce((sum, r) => sum + r.stargazers_count, 0) / 1000)}k+`,
        color: COLORS.starred,
      },
      {
        label: "Combined Forks",
        value: `${Math.round(repos.reduce((sum, r) => sum + r.forks_count, 0) / 1000)}k+`,
        color: COLORS.forked,
      },
    ]),
    "",
    githubAlert(
      "NOTE",
      "Sorted A-Z by repository name. Updated daily via GitHub Actions.",
    ),
    "",
    ...TABLE_HEADER,
    ...sortedRepos.map(allReposRow),
    pageFooter(),
  ];

  return sections.join("\n");
}

function buildReadmeIndexBlock(
  repoCount: number,
  repos: EnrichedRepo[],
): string {
  const updatedDate = new Date().toISOString().split("T")[0];
  const licenseDist = licenseDistribution(repos);

  const statBadges = [
    `![Total Repos](https://img.shields.io/badge/Total_Repos-${repoCount}-${COLORS.totalRepos}?style=${BADGE_STYLE.header})`,
    `![Last Updated](https://img.shields.io/badge/Updated-${updatedDate.replace(/-/g, "--")}-${COLORS.generated}?style=${BADGE_STYLE.header})`,
  ].join(" ");

  const navEntryIds = ["topTens", "activity", "allRepos"] as const;

  const navBadges = navEntryIds.map((id) => {
    const copy = LEADERBOARD_COPY[id];
    const label = encodeURIComponent(`${copy.icon} ${copy.badgeLabel}`);
    return `[![${copy.badgeLabel}](https://img.shields.io/badge/${label}-${copy.badgeColor}?style=${BADGE_STYLE.header}&logo=github)](./${copy.filename})`;
  });

  return [
    `> [!TIP]`,
    `> Use the navigation below to explore the awesome MCP server index.`,
    "",
    `<div align="center">`,
    "",
    statBadges,
    "",
    navBadges.join(" "),
    "",
    "</div>",
    "",
    "<details>",
    "<summary><b>ðŸ“Š License Distribution</b></summary>",
    "",
    mermaidPieChart("Repos by License", licenseDist),
    "",
    "</details>",
  ].join("\n");
}

export function updateReadmeWithIndex(
  readmePath: string,
  repos: EnrichedRepo[],
): string {
  const existingReadme = readFileSync(readmePath, "utf-8");
  const startMarker =
    "<!-- AUTO-GENERATED BY find-awesome-mcp-servers SCRIPT -->";
  const endMarker = "<!-- END AUTO-GENERATED -->";

  const startIndex = existingReadme.indexOf(startMarker);
  const endIndex = existingReadme.indexOf(endMarker);

  if (startIndex === -1 || endIndex === -1) {
    throw new Error("Could not find AUTO-GENERATED markers in README.md");
  }

  const before = existingReadme.slice(0, startIndex + startMarker.length);
  const after = existingReadme.slice(endIndex);
  const indexBlock = buildReadmeIndexBlock(repos.length, repos);

  return `${before}\n\n${indexBlock}\n\n${after}`;
}
